## 프라미스

1. promise는 resolve또는 reject를 호출해서 그 결과를 반환한다.
2. 마치 return하는 것처럼, 반드시 하나는 호출해야 한다. 호출하지 않으면 pending상태 지속
3. finally는 가장 마지막에 오지 않아도 된다.
4. finally는 인수가 없다.

```
new Promise((resolve,reject)=>{resolve('hello world!')}).finally(()=>{}).then(alert)
```

5. 위 예시의 경우처럼 finally의 인수는 없다. finally(함수)로 전달하면 그대로 수행된다.
6. then(f1,f2)가 가능한데, resolve인 경우 f1, reject인 경우 f2가 호출된다.

```
new Promise((resolve,reject)=>{resolve('hello world!')}).finally().then((x)=>{alert(x)})
```

7. 위 예시의 경우 'hello world!'가 alert로 출력된다. 프라미스 결과가 finally를 통해 전달 된 것
8. 프로미스안에 resolve 또는 reject가 다수 있더라도 가장 위에 있는 resolve또는 reject가 호출되어 반환된다. 반환된 후에는 (비동기적으로) 그 이후에 있는 (resolve/reject가 아닌) 코드도 실행된다.
9. 프라미스 체이닝은 프라미스.then().then()...then() 형식이 될 수는 있지만, `then 또한 프라미스를 return`해야 한다.

```
new Promise((resolve,reject)=>{resolve(1)}).then((result)=>return result).then(()=>{})...
```

10. 하나의 프라미스는 하나의 핸들러를 등록해서 사용한다(=동일한 프라미스에 여러개의 핸들러(then)를 각각 등록하더라도 같은 결과)
11. 프라미스를 생성할 때, 프라미스가 처리될 때 까지 기다린 뒤 그 결과를 받는다.(안에 비동기 함수(예: setTimeout)이 중첩되어있더라도 모두 기다린 후 resolve 또는 reject를 호출하여 그 값을 프라미스 객체를 통해 반환하고 그 결과가 then으로 전달된다.)

```
function nestedCallbacks() {
  return new Promise((resolve) => {
    setTimeout(() => {
      setTimeout(() => {
        setTimeout(() => {
          setTimeout(() => {
            setTimeout(() => {
              resolve("hello");
            }, 1000);
          }, 1000);
        }, 1000);
      }, 1000);
    }, 1000);
  });
}
nestedCallbacks().then(result=>alert(result))

```

12. .then((result)=>result) 라면, result는 프라미스가 아니라, 다음 then 메서드로 값이 전달되는 것
13. 프라미스에 연결된 then이 여러개라도, 하나의 then에서 오류가 발생한다면 뒤의 then을 건너뛰고 catch로 간다.
